# Offline Capabilities Strategy

This document outlines the current "Level 1" (Read-Only) offline implementation and the roadmap for "Level 2" (Read-Write) capabilities for the Pharma ERP system.

## Current Implementation: Level 1 (Read-Only)

### Overview
The application currently supports offline viewing of previously visited data. This is achieved using the `vite-plugin-pwa` which configures a Service Worker using Workbox.

### Key Components
1.  **Service Worker**: Automatically generated by Vite during the build process. It caches:
    *   **Static Assets**: HTML, CSS, JS, Images (StaleWhileRevalidate strategy).
    *   **API Responses**: Responses from `/api/*` endpoints are cached with a `NetworkFirst` strategy.
2.  **NetworkFirst Strategy**:
    *   The app tries to fetch fresh data from the server.
    *   If the network fails (offline), it falls back to the cached response.
    *   This ensures users always see the latest data when online, but can still see *something* when offline.
3.  **UI Indicators**:
    *   `ReloadPrompt.jsx`: Notifies users when a new app version is available.
    *   `OfflineIndicator.jsx`: Shows a red warning banner when the device loses connection.

### How to Verify
1.  Build the app: `npm run build`
2.  Serve the build: `npx vite preview`
3.  Open in browser and go to "Manage Stock".
4.  Go Offline (using DevTools Network tab -> "Offline").
5.  Refresh the page. The list should still load from cache.

---

## Future Roadmap: Level 2 (Read-Write)

To allow users to **create invoices or add products while offline**, the following architecture changes are required.

### 1. Local Database (IndexedDB)
We need a client-side database to store pending actions. `localStorage` is not sufficient for complex objects.
*   **Recommendation**: Use `idb` (a lightweight wrapper for IndexedDB) or `Dexie.js`.
*   **Schema**: Create a `syncQueue` object store.
    ```json
    {
      "id": "uuid-v4",
      "action": "CREATE_INVOICE",
      "payload": { ...invoiceData },
      "timestamp": 1715420000,
      "status": "PENDING" // or "FAILED"
    }
    ```

### 2. Background Sync
When the app comes back online, it needs to process this queue.
*   **Hook**: Listen to the `online` event in `App.jsx`.
*   **Processor**: A function that iterates through `syncQueue` and sends POST requests to the backend.

### 3. Conflict Resolution (Inventory)
**The Challenge**: Two users might sell the same item offline.
*   User A sells 5 units of Item X (Stock: 10) -> Offline.
*   User B sells 8 units of Item X (Stock: 10) -> Online.
*   User B's transaction processes first. Stock becomes 2.
*   User A comes online. Their transaction (sell 5) is now invalid (only 2 left).

**The Solution**:
1.  **Optimistic UI**: Let User A "finish" the sale offline and print the receipt.
2.  **Server Validation**: When User A syncs, the server rejects the transaction ("Insufficient Stock").
3.  **Error Handling**: The app must alert User A: *"Sync Error: Invoice #123 failed due to low stock."*
    *   *Design Decision*: For a strict Pharma ERP, you might want to **disable** offline sales for items with low stock to prevent this, OR accept negative stock and reconcile manually.

### 4. Implementation Steps for Level 2
1.  Install `idb`: `npm install idb`
2.  Create `src/services/offlineStorage.js` to manage the queue.
3.  Wrap API calls (e.g., `axios.post`) in a helper that:
    *   If Online -> Sends request.
    *   If Offline -> Saves to `idb` and throws a "Saved Offline" message.
4.  Create a `SyncManager` component to retry failed requests.
